name: Vercel Build Check

on:
  pull_request:
    branches: [main, develop]
  # Skip test builds on main merges - only run on PRs
  # push:
  #   branches: [main, develop]

env:
  NODE_VERSION: '20'
  PNPM_VERSION: '8.15.0'

jobs:
  vercel-build-validation:
    name: Vercel Build Validation
    runs-on: ubuntu-latest
    timeout-minutes: 15
    # Only run on pull requests, skip on main branch merges
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: |
          set -euo pipefail
          export ENABLE_EXPERIMENTAL_COREPACK=1
          corepack enable || true
          corepack prepare pnpm@${{ env.PNPM_VERSION }} --activate || true
          pnpm install --frozen-lockfile

      - name: Validate vercel.json
        run: |
          set -euo pipefail
          echo "ðŸ” Validating vercel.json..."
          if [ ! -f vercel.json ]; then
            echo "âŒ vercel.json not found"
            exit 1
          fi
          
          # Check if vercel.json is valid JSON
          if ! node -e "JSON.parse(require('fs').readFileSync('vercel.json', 'utf8'))"; then
            echo "âŒ vercel.json is not valid JSON"
            exit 1
          fi
          
          # Check if buildCommand exists
          BUILD_CMD=$(node -e "console.log(JSON.parse(require('fs').readFileSync('vercel.json', 'utf8')).buildCommand || '')")
          if [ -z "$BUILD_CMD" ]; then
            echo "âš ï¸  buildCommand not specified in vercel.json"
          else
            echo "âœ… buildCommand: $BUILD_CMD"
          fi
          
          # Check if build script exists
          if [ -f vercel-build.sh ]; then
            if [ ! -x vercel-build.sh ]; then
              echo "âš ï¸  vercel-build.sh is not executable"
              chmod +x vercel-build.sh
            fi
            echo "âœ… vercel-build.sh exists and is executable"
          else
            echo "âš ï¸  vercel-build.sh not found"
          fi
          
          echo "âœ… vercel.json validation passed"

      - name: Generate Prisma Client (if needed)
        run: |
          set -euo pipefail
          echo "ðŸ”¨ Generating Prisma client..."
          pnpm run db:generate || echo "âš ï¸ Prisma generation skipped (DATABASE_URL may not be available)"
        continue-on-error: true
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL || 'postgresql://localhost:5432/test' }}

      - name: Build application (simulating Vercel build)
        run: |
          set -euo pipefail
          echo "ðŸ”¨ Building application (simulating Vercel build environment)..."
          
          # Set environment variables similar to Vercel
          export NODE_ENV=production
          export PRISMA_CLIENT_ENGINE_TYPE=wasm
          export ENABLE_EXPERIMENTAL_COREPACK=1
          
          # Run the same build command that Vercel would use
          if [ -f vercel-build.sh ]; then
            bash vercel-build.sh
          else
            # Fallback to standard build if vercel-build.sh doesn't exist
            pnpm run build
          fi
          
          echo "âœ… Build completed successfully"

      - name: Validate build output
        run: |
          set -euo pipefail
          echo "ðŸ” Validating build output..."
          
          if ! pnpm run validate:build; then
            echo "âŒ Build validation failed"
            exit 1
          fi
          
          echo "âœ… Build validation passed"

      - name: Check build artifacts
        run: |
          set -euo pipefail
          echo "ðŸ” Checking build artifacts..."
          
          REQUIRED_FILES=(
            ".next/BUILD_ID"
            ".next/package.json"
          )
          
          REQUIRED_DIRS=(
            ".next/static"
            ".next/server"
          )
          
          MISSING_FILES=()
          MISSING_DIRS=()
          
          for file in "${REQUIRED_FILES[@]}"; do
            if [ ! -f "$file" ]; then
              MISSING_FILES+=("$file")
            fi
          done
          
          for dir in "${REQUIRED_DIRS[@]}"; do
            if [ ! -d "$dir" ]; then
              MISSING_DIRS+=("$dir")
            fi
          done
          
          if [ ${#MISSING_FILES[@]} -gt 0 ] || [ ${#MISSING_DIRS[@]} -gt 0 ]; then
            echo "âŒ Missing required build artifacts:"
            [ ${#MISSING_FILES[@]} -gt 0 ] && printf '  Files: %s\n' "${MISSING_FILES[@]}"
            [ ${#MISSING_DIRS[@]} -gt 0 ] && printf '  Directories: %s\n' "${MISSING_DIRS[@]}"
            exit 1
          fi
          
          echo "âœ… All required build artifacts present"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: vercel-build-check-artifacts
          path: .next/
          retention-days: 7

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Vercel Build Check')
            );
            
            const body = `## âœ… Vercel Build Check Passed\n\nThis PR has been validated for Vercel deployment:\n\n- âœ… vercel.json configuration valid\n- âœ… Build script executable\n- âœ… Application builds successfully\n- âœ… Build output validated\n- âœ… All required artifacts present\n\n**Ready for Vercel deployment!**`;
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
        continue-on-error: true
